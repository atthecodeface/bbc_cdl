<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>CDL Modules: cdl/cpu/riscv/src/riscv_i32_debug.cdl File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CDL Modules
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_b89025be567f5b6d36b8bc23257fdaf4.html">cdl</a></li><li class="navelem"><a class="el" href="dir_85b38f643f542dbcc5b646a1975c7ae1.html">cpu</a></li><li class="navelem"><a class="el" href="dir_703494e7c6a3685d0e145f1a6da3bd51.html">riscv</a></li><li class="navelem"><a class="el" href="dir_35e6082806cf4b6f47701df90a22b5bf.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">riscv_i32_debug.cdl File Reference<div class="ingroups"><a class="el" href="group__riscv__i32__debug.html">riscv_i32_debug</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>RISC-V debug module with APB interface.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>RISC-V debug module with APB interface. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>(C) 2018, Gavin J Stark. All rights reserved.</dd>
<dd>
Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a>. Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</dd></dl>
<p>CDL implementation of a RISC-V debug module supporting up to 64 HARTs using PDMs</p>
<h1>Implementation of Minimalist Debug Module </h1>
<h2>Supported features (section 1.4) </h2>
<p>The specification indicates that "The debug interface described in
this specification supports the following features", with a bullet list of features. It does not state that the list of features are required, but perhaps it should, since that would appear to be the purpose of a standardized debug interface.</p>
<p>So, assuming that the supported features are required, the implementation must provide:</p>
<p>RV32 support (not RV64 or RV128 if the harts <em>have</em> to be RV32...)</p>
<p>Debug of any individual hart attached to the debugger</p>
<p>Debug of harts from the first instruction out of reset</p>
<p>Halt of hart on software breakpoint execution</p>
<p>Single-step of hart</p>
<p>EITHER 'a mechanism to execute arbitrary instructions' or 'a system bus master'</p>
<p>Abstract commands (section 3.5.1) can be either 'Access Register Command' or 'Quick Access'. The first must be supported; this has to copy data from a dataX register (if write=0 and transfer=1); copy data in to a dataX register (if write=1 and trasfer=1); execute the program buffer.</p>
<p>It is not quite clear where the data is copied to and from.</p>
<p>Can we add another abstract command that is 'force debug trap to PC x'? This would set dpc to be the PC being fetched, and would replace the fetch PC with x and the fetch privilege mode to be debug.</p>
<h2>Overview of design choices </h2>
<p>Only RV32 and RV32C are supported.</p>
<p>Debug of a single hart at any one time is supported.</p>
<p>Debug of many harts at any one time is not required.</p>
<p>Insertion of a single RV32 or RV32C instruction to the pipeline is supported, with result of an instruction execution being available (to support reading GPRs, CSRs and memory; to test execution of individual instructions). (What PC is used for this instruction? We will run with 0xffffff00, and if this is a JALR then execution continues until an ebreak OR it returns to 0xffffffNN)</p>
<p>A system bus master is not supported.</p>
<h2>Detailed design choices </h2>
<p>No support for multiple hart select +++++++++++++++++++++++++++++++++++</p>
<p>There is no need for a hart array matrix (sections 3.3.1 and 3.3.2), just a single selector. This requires hawindowsel (3.11.4) and hawindow (3.11.5) to be read-only of 0.</p>
<p>The other impact is that the 'all' and 'any' variants in dmstatus will return the same value.</p>
<p>Reset +++++</p>
<p>ndmreset has to be provided from the DM to the PDM, which presents it as an output. In many instances this will do <em>nothing</em> except reset the pipeline, since it does not make sense to have the DM reset a swathe of other system that has to keep running. But it may be used in other instances, in which case the signal <em>must</em> not be fed back to reset any part of the DM or PDM.</p>
<p>System bus access +++++++++++++++++</p>
<p>System bus access is not supported.</p>
<p>Hence sbcs (section 3.11.19) and the sbaddress registers (sections 3.11.18/20/21/22) and sbdata (section 3.11.23/24/25/26) are zero.</p>
<p>Authentication ++++++++++++++</p>
<p>Authentication is not supported (other means in the system must prevent access to the debugger; for many of the known target systems there is no necessity of authentication, and for others there have to be more secure mechanisms than the DM can provide).</p>
<p>Hence authdata (section 3.11.13) is not supported.</p>
<p>Other registers +++++++++++++++</p>
<p>Device tree (section 3.11.9) is 0.</p>
<p>Next debug module (section 3.11.10) is 0.</p>
<p>Haltsum +++++++</p>
<p>The halt summary registers provide indications as to which sets of harts are halted.</p>
<p>The harts are known to be halted when they report their state.</p>
<p>haltsum1 (section 3.11.15) may be required, if the DM is configured for &gt;32 harts. It reflects with 'halted[32;0]' or 'halted[32;32]', if 64 harts are configured.</p>
<p>haltsum2 (section 3.11.16) is not required for systems with fewer than 1k harts, hence this is not supported.</p>
<p>haltsum3 (section 3.11.17) is not required for systems with fewer than 32k harts, hence this is not supported.</p>
<p>Debug instruction execution +++++++++++++++++++++++++++</p>
<p>The abstract command 'Access Register Command' requires copying data to a CSR or GPR from data0 (note this is only data0, since that is all that is supported); it also requires copying of data back from a CSR or GPR to data0.</p>
<p>There must therefore be a method of executing a CSR read or write without changing the PC*; there must be a way to read or write a GPR without changing the PC*.</p>
<p>Hence the DM must be able to pass instructions to a halted hart that execute in debug mode (with what privilege?), and which provide an acknowledgement when the hart has completed the instruction, returning the data passed to rfw.</p>
<p>An instruction to read a GPR would be (for example) 'ori rN, rN, 0'.</p>
<p>Two instructions are required to write a GPR: 'lui rN, 0x12345' and 'ori rN, rN, 0x678'.</p>
<p>Reading the PC can be performed with 'auipc r0, 0'</p>
<p>Reading a CSR can be performed with 'csrrsi r0, 0, CSR' Note that reading the PC can be performed (how?) through reading dpc</p>
<p>Writing a CSR is a pain - it requires a GPR (rN) to be preserved, then 'CSRRW x0, csr, rN' to be performed, then rN to be recovered. Potentially dscratch0 can be used for this; this forces dscratch0 to be supported <em>sigh</em>. This might also not fit the requirement of the debug specification? Note that reading the PC can be performed (how?) through writing dpc?</p>
<p>Given the issues here, it seems sensible for the PDM to have a concept of a debug instruction, which has a different (but simple) decoder to rv32i/c.</p>
<p>A method must also be supported to provide for an instruction to be executed</p>
<p>Abstract commands (section 3.5.1) can be either or 'Quick Access'. The first must be supported; this has to copy data from a dataX register (if write=0 and transfer=1); copy data in to a dataX register (if write=1 and trasfer=1); execute the program buffer.</p>
<p>Program buffer (section 3.6) ++++++++++++++++++++++++++++</p>
<p>Although the program buffer is not required, the implementation supports a program buffer size of 1.</p>
<p>From section 3.6 and 3.11.1 the choice of progbufsize of 1 implies impebreak is 1.</p>
<p>From section 3.11.12, progbuf0 must be supported as read/write; reading or writing this register during an abstrct command causes cmderr to be set. Writing when busy is set does not effect the register.</p>
<p>The instruction in progbuf0 can be executed by a using the 'Access Register Abstract Command'. The instruction is fed to a pipeline, and executed with a program counter of 0xffffff00. If the instruction generates an exception then the exception is NOT taken but execution halts and cmderr is set to 3. If the instruction changes the PC then execution must continue at that PC, in debug mode, until (if ever) a software breakpoint is hit or it returns to 0xffffffNN.</p>
<p>Debug mode can be exited using a dret in progbuf0.</p>
<p>Data access +++++++++++</p>
<p>A single data register, data0, is supported. Hence datacount will be 1.</p>
<p>From section 3.11.11, data0 must be supported as read/write; reading or writing this register during an abstrct command causes cmderr to be set. Writing when busy is set does not effect the register.</p>
<p>The harts may support dscratch registers, but the architecture does not permit the data0 register to map to a dscratch register; hence hartinfo (section 3.11.3) must be 0 except for the number of dscratch registers; this must be the same (in this implementation) for all the harts, and has to be a configuration constant.</p>
<p>Abstract commands +++++++++++++++++</p>
<p>Writing to command (section 3.11.7) can cause an abstract command to be performed.</p>
<p>If the abstract command is busy then it sets cmderr and ignores the write</p>
<p>If cmderr is already set then it ignores the write (without changing cmderr)</p>
<p>This is actually a writable register that, as a side effect of write, causes it to be executed.</p>
<p>The abstractauto register (section 3.11.8) has a read/write of bit 0 of autoexecprobuf and read/write of bit 0 of autoexecdata, so that read/writes of data0 or may foce abstract command execution Or hardwire to 0?</p>
<p>Debug CSRs ++++++++++</p>
<p>dpc is set to the current pc on an ebreak; it is set to the current pc if an instruction is flagged as a 'debug ebreak'; if a halt request is received by the PDM then instruction input feed is flagged as a 'debug ebreak'.</p>
<p>The PDM can present a 'debug resume' in which case the pipeline will set itself to fetch 'dpc'. (This is 'execute a dret'?)</p>
<p>dcsr has 'prv' set to the privilege level any time dpc is set. It may be written.</p>
<p>Halting execution +++++++++++++++++</p>
<p>The DM may request that a PDM halt.</p>
<p>This makes the PDM flag an instruction fetch as 'debug ebreak', which forces the pipeline to enter debug mode, set dcsr.prv, set dpc, and (as it is requesting instructions in debug mode) the PDM kills instruction fetching. The PDM can monitor the instruction retirement to know that the halt has been achieved.</p>
<p>Resuming execution +++++++++++++++++</p>
<p>The DM may request that a PDM resume, if the pipeline is in debug mode. This is handled by the DM issuing an 'execute dret' control.</p>
<p>The DM</p>
<p>Single step +++++++++++</p>
<p>Single step is performed by the PDM by allowing a single instruction fetch to go through, and for a following instruction fetch to be passed to the pipeline with 'debug ebreak' - which forces it to be interpreted as an ebreak. Is this 'execute dret' then 'ebreak after next ifetch'?</p>
<p>Step 'n' ++++++++</p>
<p>The PDM could have a 'count down by N' rather than single step counter.</p>
<p>Reading CSRs</p>
<p>Reading memory</p>
<p>Trace, software breakpoint +++++++++++++++++++++++++++</p>
<p>A hart needs to be able to indicate that it has 'status'; such as a software breakpoint has occurred or a hardware trace point has forced a halt.</p>
<h1>Extensions </h1>
<p>In theory a larger progbufsize can be supported.</p>
<p>Then one MIGHT be able to just request progbuf run on a hart</p>
<p>In this case the DM would have to:</p>
<p>Request quick-access halt of the hart (dpc &lt;= pc of instruction that was stopped from execution)</p>
<p>Request execution of each instruction individually from progbuf</p>
<ul>
<li>request execution of instruction 0 (from PC=0xFFFFFF00)<ul>
<li>wait for acknowledgement - if ack and PC not changed (no branch, dret, etc?) then</li>
<li>request execution of instruction 1 etc</li>
</ul>
</li>
</ul>
<p>Perhaps a better approach would be to allow a 'force debug trap', which would enter debug mode, set dpc to the next PC, and set PC to a known value. ) </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structriscv__i32__debug_1_1t__apb__state"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__riscv__i32__debug.html#structriscv__i32__debug_1_1t__apb__state">riscv_i32_debug::t_apb_state</a></td></tr>
<tr class="separator:structriscv__i32__debug_1_1t__apb__state"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structriscv__i32__debug_1_1t__debug__state"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__riscv__i32__debug.html#structriscv__i32__debug_1_1t__debug__state">riscv_i32_debug::t_debug_state</a></td></tr>
<tr class="separator:structriscv__i32__debug_1_1t__debug__state"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structriscv__i32__debug_1_1t__dmstatus"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__riscv__i32__debug.html#structriscv__i32__debug_1_1t__dmstatus">riscv_i32_debug::t_dmstatus</a></td></tr>
<tr class="separator:structriscv__i32__debug_1_1t__dmstatus"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structriscv__i32__debug_1_1t__debug__combs"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__riscv__i32__debug.html#structriscv__i32__debug_1_1t__debug__combs">riscv_i32_debug::t_debug_combs</a></td></tr>
<tr class="separator:structriscv__i32__debug_1_1t__debug__combs"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceriscv__i32__debug"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceriscv__i32__debug.html">riscv_i32_debug</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga720a300809e2f960eba679f14c8c11a9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__riscv__i32__debug.html#ga720a300809e2f960eba679f14c8c11a9">riscv_i32_debug::t_write_action</a> { <br />
&#160;&#160;<a class="el" href="group__riscv__i32__debug.html#gga720a300809e2f960eba679f14c8c11a9a8ba54235a58a625c176f663e38789f7d">riscv_i32_debug::write_action_none</a>, 
<br />
&#160;&#160;<a class="el" href="group__riscv__i32__debug.html#gga720a300809e2f960eba679f14c8c11a9a7b67371f55d60c0b3a31111ac8c4124b">riscv_i32_debug::write_action_data0</a>, 
<br />
&#160;&#160;<a class="el" href="group__riscv__i32__debug.html#gga720a300809e2f960eba679f14c8c11a9a4d51d0e6373f1438c40556d90a574121">riscv_i32_debug::write_action_progbuf0</a>, 
<br />
&#160;&#160;<a class="el" href="group__riscv__i32__debug.html#gga720a300809e2f960eba679f14c8c11a9a5ac0f67426495ad4ab11ef699975e8cb">riscv_i32_debug::write_action_control</a>, 
<br />
&#160;&#160;<a class="el" href="group__riscv__i32__debug.html#gga720a300809e2f960eba679f14c8c11a9af3ffe70f0c018701b32f0d919e6c4fba">riscv_i32_debug::write_action_abstract_cs</a>, 
<br />
&#160;&#160;<a class="el" href="group__riscv__i32__debug.html#gga720a300809e2f960eba679f14c8c11a9ab3bbae0f0e42df938b0e95889697bec9">riscv_i32_debug::write_action_abstract_cmd</a>
<br />
 }</td></tr>
<tr class="separator:ga720a300809e2f960eba679f14c8c11a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32168a6eecade3b532d0a8976c822c56"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__riscv__i32__debug.html#ga32168a6eecade3b532d0a8976c822c56">riscv_i32_debug::t_read_select</a> { <br />
&#160;&#160;<a class="el" href="group__riscv__i32__debug.html#gga32168a6eecade3b532d0a8976c822c56a982f99a60a3a55e3ec8830a37d6c5564">riscv_i32_debug::read_select_zero</a>, 
<br />
&#160;&#160;<a class="el" href="group__riscv__i32__debug.html#gga32168a6eecade3b532d0a8976c822c56a6a8c1c568350042cb709628cfda323fd">riscv_i32_debug::read_select_dmstatus</a>, 
<br />
&#160;&#160;<a class="el" href="group__riscv__i32__debug.html#gga32168a6eecade3b532d0a8976c822c56a17017d0057544c3b1d38fd3f7bf6887e">riscv_i32_debug::read_select_dmcontrol</a>, 
<br />
&#160;&#160;<a class="el" href="group__riscv__i32__debug.html#gga32168a6eecade3b532d0a8976c822c56a8bf913edf16f3c35d0a28908966c9820">riscv_i32_debug::read_select_abstractcs</a>, 
<br />
&#160;&#160;<a class="el" href="group__riscv__i32__debug.html#gga32168a6eecade3b532d0a8976c822c56ac4742e666cfa00991742f526c7568e68">riscv_i32_debug::read_select_data0</a>, 
<br />
&#160;&#160;<a class="el" href="group__riscv__i32__debug.html#gga32168a6eecade3b532d0a8976c822c56a2b2dc06eebc804b7d7b5cc772d47e319">riscv_i32_debug::read_select_progbuf0</a>, 
<br />
&#160;&#160;<a class="el" href="group__riscv__i32__debug.html#gga32168a6eecade3b532d0a8976c822c56ab1658ab611ce9da12f8d4c385ecec710">riscv_i32_debug::read_select_haltsum0</a>, 
<br />
&#160;&#160;<a class="el" href="group__riscv__i32__debug.html#gga32168a6eecade3b532d0a8976c822c56a00fc32a867e2c41ec686cb45dd10e573">riscv_i32_debug::read_select_haltsum1</a>
<br />
 }</td></tr>
<tr class="separator:ga32168a6eecade3b532d0a8976c822c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga127ff86c22a10d0d082a407eedd2913a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__riscv__i32__debug.html#ga127ff86c22a10d0d082a407eedd2913a">riscv_i32_debug::t_apb_address</a> { <br />
&#160;&#160;<a class="el" href="group__riscv__i32__debug.html#gga127ff86c22a10d0d082a407eedd2913aa90fa6772a92c854d1b487f40f24b1f3a">riscv_i32_debug::dm_addr_dmcontrol</a> = 0x10, 
<br />
&#160;&#160;<a class="el" href="group__riscv__i32__debug.html#gga127ff86c22a10d0d082a407eedd2913aa1290b86720e9c355a5e62b254f9a375f">riscv_i32_debug::dm_addr_dmstatus</a> = 0x11, 
<br />
&#160;&#160;<a class="el" href="group__riscv__i32__debug.html#gga127ff86c22a10d0d082a407eedd2913aaf4a2b17ef0d69b62b02f7cf2ad54bda2">riscv_i32_debug::dm_addr_hart_info</a> = 0x12, 
<br />
&#160;&#160;<a class="el" href="group__riscv__i32__debug.html#gga127ff86c22a10d0d082a407eedd2913aa5b6886112db88722a75bbe398ad66796">riscv_i32_debug::dm_addr_hart_window_sel</a> = 0x14, 
<br />
&#160;&#160;<a class="el" href="group__riscv__i32__debug.html#gga127ff86c22a10d0d082a407eedd2913aa962785d63a69d42d0787d37b764db11e">riscv_i32_debug::dm_addr_hart_window</a> = 0x15, 
<br />
&#160;&#160;<a class="el" href="group__riscv__i32__debug.html#gga127ff86c22a10d0d082a407eedd2913aab671e918893f639893b64cec2d9018c6">riscv_i32_debug::dm_addr_abstract_cs</a> = 0x16, 
<br />
&#160;&#160;<a class="el" href="group__riscv__i32__debug.html#gga127ff86c22a10d0d082a407eedd2913aa69bb0b9b3f8dba3993d56486872c86dd">riscv_i32_debug::dm_addr_abstract_cmd</a> = 0x17, 
<br />
&#160;&#160;<a class="el" href="group__riscv__i32__debug.html#gga127ff86c22a10d0d082a407eedd2913aadbe74b11ed3d0a8802f64ba2216223e4">riscv_i32_debug::dm_addr_abstract_cmd_autoexec</a> = 0x18, 
<br />
&#160;&#160;<a class="el" href="group__riscv__i32__debug.html#gga127ff86c22a10d0d082a407eedd2913aa58f179f5381b3b9a35f6c3254b8d3c53">riscv_i32_debug::dm_addr_dev_tree_addr0</a> = 0x19, 
<br />
&#160;&#160;<a class="el" href="group__riscv__i32__debug.html#gga127ff86c22a10d0d082a407eedd2913aadc77a6ab63832945bf934badcfcf8d24">riscv_i32_debug::dm_addr_next_dm</a> = 0x1a, 
<br />
&#160;&#160;<a class="el" href="group__riscv__i32__debug.html#gga127ff86c22a10d0d082a407eedd2913aa52b25b1f2e0b42d1d828f02fc45612c7">riscv_i32_debug::dm_addr_data0</a> = 0x04, 
<br />
&#160;&#160;<a class="el" href="group__riscv__i32__debug.html#gga127ff86c22a10d0d082a407eedd2913aa7da2483e69086b30b444323c0cd991be">riscv_i32_debug::dm_addr_progbuf0</a> = 0x20, 
<br />
&#160;&#160;<a class="el" href="group__riscv__i32__debug.html#gga127ff86c22a10d0d082a407eedd2913aac2b18b4b49f10efb42cb742515689c69">riscv_i32_debug::dm_addr_authdata</a> = 0x30, 
<br />
&#160;&#160;<a class="el" href="group__riscv__i32__debug.html#gga127ff86c22a10d0d082a407eedd2913aa70d6b2492f03488cdad74831a48bf257">riscv_i32_debug::dm_addr_haltsum0</a> = 0x40, 
<br />
&#160;&#160;<a class="el" href="group__riscv__i32__debug.html#gga127ff86c22a10d0d082a407eedd2913aaebca26c0fec05790ad366c66d4a8ec6f">riscv_i32_debug::dm_addr_haltsum1</a> = 0x13
<br />
 }</td></tr>
<tr class="separator:ga127ff86c22a10d0d082a407eedd2913a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gad46a58e1af7d82d11ac7eced08c5308f"><td class="memItemLeft" align="right" valign="top">constant integer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__riscv__i32__debug.html#gad46a58e1af7d82d11ac7eced08c5308f">riscv_i32_debug::max_hart_minus_one</a> =63</td></tr>
<tr class="separator:gad46a58e1af7d82d11ac7eced08c5308f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2840127b2bc648279f9dd8855ef58550"><td class="memItemLeft" align="right" valign="top">constant bit[64]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__riscv__i32__debug.html#ga2840127b2bc648279f9dd8855ef58550">riscv_i32_debug::valid_hart_mask</a> = 64hffffffffffffffff</td></tr>
<tr class="separator:ga2840127b2bc648279f9dd8855ef58550"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Sep 30 2018 17:21:43 for CDL Modules by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
