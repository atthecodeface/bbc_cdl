<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>CDL Modules: cdl/inc/bbc_micro_types.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CDL Modules
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_b89025be567f5b6d36b8bc23257fdaf4.html">cdl</a></li><li class="navelem"><a class="el" href="dir_af298877340144433539b3d17cce7a97.html">inc</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">bbc_micro_types.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>BBC micro types header file for CDL.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>BBC micro types header file for CDL. </p>
<p>Copyright (C) 2016-2017, Gavin J Stark. All rights reserved.</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p>
<p><a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p>Header file for the types shared by more than one CDL module for the BBC micro implementation </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structt__bbc__keyboard"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bbc__micro__types_8h.html#structt__bbc__keyboard">t_bbc_keyboard</a></td></tr>
<tr class="separator:structt__bbc__keyboard"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structt__bbc__display"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bbc__micro__types_8h.html#structt__bbc__display">t_bbc_display</a></td></tr>
<tr class="separator:structt__bbc__display"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structt__bbc__display__sram__write"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bbc__micro__types_8h.html#structt__bbc__display__sram__write">t_bbc_display_sram_write</a></td></tr>
<tr class="separator:structt__bbc__display__sram__write"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structt__bbc__floppy__sector__id"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bbc__micro__types_8h.html#structt__bbc__floppy__sector__id">t_bbc_floppy_sector_id</a></td></tr>
<tr class="separator:structt__bbc__floppy__sector__id"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structt__bbc__floppy__op"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bbc__micro__types_8h.html#structt__bbc__floppy__op">t_bbc_floppy_op</a></td></tr>
<tr class="separator:structt__bbc__floppy__op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structt__bbc__floppy__response"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bbc__micro__types_8h.html#structt__bbc__floppy__response">t_bbc_floppy_response</a></td></tr>
<tr class="separator:structt__bbc__floppy__response"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structt__bbc__floppy__sram__request"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bbc__micro__types_8h.html#structt__bbc__floppy__sram__request">t_bbc_floppy_sram_request</a></td></tr>
<tr class="separator:structt__bbc__floppy__sram__request"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structt__bbc__floppy__sram__response"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bbc__micro__types_8h.html#structt__bbc__floppy__sram__response">t_bbc_floppy_sram_response</a></td></tr>
<tr class="separator:structt__bbc__floppy__sram__response"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structt__bbc__clock__control"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bbc__micro__types_8h.html#structt__bbc__clock__control">t_bbc_clock_control</a></td></tr>
<tr class="separator:structt__bbc__clock__control"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structt__bbc__clock__status"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bbc__micro__types_8h.html#structt__bbc__clock__status">t_bbc_clock_status</a></td></tr>
<tr class="separator:structt__bbc__clock__status"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structt__bbc__micro__sram__request"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bbc__micro__types_8h.html#structt__bbc__micro__sram__request">t_bbc_micro_sram_request</a></td></tr>
<tr class="separator:structt__bbc__micro__sram__request"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structt__bbc__micro__sram__response"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bbc__micro__types_8h.html#structt__bbc__micro__sram__response">t_bbc_micro_sram_response</a></td></tr>
<tr class="separator:structt__bbc__micro__sram__response"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a51ee698f2790beed10c5dbed353e12d6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bbc__micro__types_8h.html#a51ee698f2790beed10c5dbed353e12d6">t_bbc_pixels_per_clock</a> { <br />
&#160;&#160;<a class="el" href="bbc__micro__types_8h.html#a51ee698f2790beed10c5dbed353e12d6a1cf479e55c0f6a6a54a75568b0fac2ee">bbc_ppc_1</a>, 
<br />
&#160;&#160;<a class="el" href="bbc__micro__types_8h.html#a51ee698f2790beed10c5dbed353e12d6a368f7255dceaf9746d6516fc936fe5cc">bbc_ppc_2</a>, 
<br />
&#160;&#160;<a class="el" href="bbc__micro__types_8h.html#a51ee698f2790beed10c5dbed353e12d6a05d9a40c81ac220076fe3a94b2c8785a">bbc_ppc_4</a>, 
<br />
&#160;&#160;<a class="el" href="bbc__micro__types_8h.html#a51ee698f2790beed10c5dbed353e12d6a55dd803f4ea17389d2061cf2a4529f65">bbc_ppc_6</a>, 
<br />
&#160;&#160;<a class="el" href="bbc__micro__types_8h.html#a51ee698f2790beed10c5dbed353e12d6a0b3ca4328f764f7d8498e2a8e4d2f2ee">bbc_ppc_8</a>
<br />
 }</td></tr>
<tr class="separator:a51ee698f2790beed10c5dbed353e12d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af137b3d5b55b2c9a56985083800706"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bbc__micro__types_8h.html#a5af137b3d5b55b2c9a56985083800706">t_bbc_csr_select</a> { <br />
&#160;&#160;<a class="el" href="bbc__micro__types_8h.html#a5af137b3d5b55b2c9a56985083800706a9ee4a4b66e114dcd6900262f06568684">bbc_csr_select_clocks</a> = 0, 
<br />
&#160;&#160;<a class="el" href="bbc__micro__types_8h.html#a5af137b3d5b55b2c9a56985083800706a69c0335e582f51823e82af498c09ed6e">bbc_csr_select_display</a> = 1, 
<br />
&#160;&#160;<a class="el" href="bbc__micro__types_8h.html#a5af137b3d5b55b2c9a56985083800706ae9cfc6676412f5b0dbc4c449c19af229">bbc_csr_select_floppy</a> = 2, 
<br />
&#160;&#160;<a class="el" href="bbc__micro__types_8h.html#a5af137b3d5b55b2c9a56985083800706ae6f866f9c292decf83279fc4d7858361">bbc_csr_select_keyboard</a> = 3, 
<br />
&#160;&#160;<a class="el" href="bbc__micro__types_8h.html#a5af137b3d5b55b2c9a56985083800706a5a2500ec6c113142c4e22329b28fed83">bbc_csr_select_framebuffer</a> = 4
<br />
 }</td></tr>
<tr class="separator:a5af137b3d5b55b2c9a56985083800706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b75e2f51d5bd3163e0b149f3fdd95b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bbc__micro__types_8h.html#ac4b75e2f51d5bd3163e0b149f3fdd95b">t_bbc_sram_select</a> { <br />
&#160;&#160;<a class="el" href="bbc__micro__types_8h.html#ac4b75e2f51d5bd3163e0b149f3fdd95baf07234e37f7d06f240f83d4a5b85bb11">bbc_sram_select_micro</a> = 0, 
<br />
&#160;&#160;<a class="el" href="bbc__micro__types_8h.html#ac4b75e2f51d5bd3163e0b149f3fdd95bac37abdb49644780f910144ba6a8de3bb">bbc_sram_select_display</a> = 1, 
<br />
&#160;&#160;<a class="el" href="bbc__micro__types_8h.html#ac4b75e2f51d5bd3163e0b149f3fdd95baf318febf0ea7251d51c5b2d7c8e96bdd">bbc_sram_select_floppy</a> = 2, 
<br />
&#160;&#160;<a class="el" href="bbc__micro__types_8h.html#ac4b75e2f51d5bd3163e0b149f3fdd95ba072ca0f41e8ce2dcf74f21f2fbd0bf55">bbc_sram_select_cpu</a> = 16, 
<br />
&#160;&#160;<a class="el" href="bbc__micro__types_8h.html#ac4b75e2f51d5bd3163e0b149f3fdd95ba9612dbdf7efa46010c8dccfaefc10c97">bbc_sram_select_cpu_ram_0</a> = 16, 
<br />
&#160;&#160;<a class="el" href="bbc__micro__types_8h.html#ac4b75e2f51d5bd3163e0b149f3fdd95ba7540f47faa13853156d7d799e0ca4788">bbc_sram_select_cpu_ram_1</a> = 17, 
<br />
&#160;&#160;<a class="el" href="bbc__micro__types_8h.html#ac4b75e2f51d5bd3163e0b149f3fdd95bafc4212f67cbaeb213173caba0a4d2611">bbc_sram_select_cpu_os</a> = 18, 
<br />
&#160;&#160;<a class="el" href="bbc__micro__types_8h.html#ac4b75e2f51d5bd3163e0b149f3fdd95ba2ee979e2140def0be868f4eb44eb932f">bbc_sram_select_cpu_teletext</a> = 20, 
<br />
&#160;&#160;<a class="el" href="bbc__micro__types_8h.html#ac4b75e2f51d5bd3163e0b149f3fdd95bac975572c2d4aec3c2a2374f8a759badf">bbc_sram_select_cpu_rom_0</a> = 24, 
<br />
&#160;&#160;<a class="el" href="bbc__micro__types_8h.html#ac4b75e2f51d5bd3163e0b149f3fdd95ba3e4d9b1f0f56cc53d11ec951df844620">bbc_sram_select_cpu_rom_1</a> = 25, 
<br />
&#160;&#160;<a class="el" href="bbc__micro__types_8h.html#ac4b75e2f51d5bd3163e0b149f3fdd95ba4d76984004b14d111cfc3753e0068fce">bbc_sram_select_cpu_rom_2</a> = 26, 
<br />
&#160;&#160;<a class="el" href="bbc__micro__types_8h.html#ac4b75e2f51d5bd3163e0b149f3fdd95ba25d3e957a48c44146db6495500f16de3">bbc_sram_select_cpu_rom_3</a> = 27
<br />
 }</td></tr>
<tr class="separator:ac4b75e2f51d5bd3163e0b149f3fdd95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structt__bbc__keyboard" id="structt__bbc__keyboard"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct t_bbc_keyboard</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>The BBC keyboard consists of a keyboard matrix with ten columns of eight rows of keys. The columns can be individually powered, and then the eight rows can be read as a byte to see which of the column's keys is pressed. There is an additional 'Break' key that is independent of the keyboard matrix, that provides a reset signal to the motherboard.</p>
<p>This structure is used to pass the keyboard state in to the BBC micro implementation - since an ASIC of FPGA does not contain a physical keyboard, the key pressed information needs to be conveyed over a bus from outside. This structure permits this. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a1eb73d29398f04221ebe062b91eb268b"></a>bit[64]</td>
<td class="fieldname">
keys_down_cols_0_to_7</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ad334d2f339540a2dd95d193ee9468f29"></a>bit[16]</td>
<td class="fieldname">
keys_down_cols_8_to_9</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a1390a6ff0696c414e80fbc94470d08fb"></a>bit</td>
<td class="fieldname">
reset_pressed</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structt__bbc__display" id="structt__bbc__display"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct t_bbc_display</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>The BBC micro output from its video ULA is separate red, green and blue pixel data, and sync signals. This structure conveys this information out of the BBC implementation, plus the number of pixels per clock, so that the display interface may be clocked at 2MHz. For modes where there are fewer than 8 pixels per clock, the red, green and blue data is replicated throughout the bus - so the only real need for pixels_per_clock is to indicate if the pixel clock rate is 12MHz or 16MHz (it is 12MHz if bbc_ppc_6) </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="acc639fdd29707baac34fb53911983c6c"></a>bit[8]</td>
<td class="fieldname">
blue</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="adf609ed88b453ccdb7421f0dc849feb1"></a>bit</td>
<td class="fieldname">
clock_enable</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a51e9473609e02860ecc681aa6b6a0fca"></a>bit[8]</td>
<td class="fieldname">
green</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ac941458f732ae20d7ad42d055813f1b2"></a>bit</td>
<td class="fieldname">
hsync</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ac3a6260daf92441e029f76b56fb91979"></a><a class="el" href="bbc__micro__types_8h.html#a51ee698f2790beed10c5dbed353e12d6">t_bbc_pixels_per_clock</a></td>
<td class="fieldname">
pixels_per_clock</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ad1eedc1deaab46794ed1492bfe4a78e8"></a>bit[8]</td>
<td class="fieldname">
red</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a8c2e3cb46118b7d1151938c58323c26f"></a>bit</td>
<td class="fieldname">
vsync</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structt__bbc__display__sram__write" id="structt__bbc__display__sram__write"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct t_bbc_display_sram_write</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>To ease implementation of display framebuffers in target hardware there is a CDL module supplied called '<a class="el" href="namespacebbc__display__sram.html">bbc_display_sram</a>'. This module converts from a <a class="el" href="bbc__micro__types_8h.html#structt__bbc__display">t_bbc_display</a> structure to a 3bpp frame buffer (RGB per pixel). The output from this module is therefore a stream of SRAM write transactions, each of 16 pixels.</p>
<p>The module itself is configured through a CSR request interface to set the base address of the frame buffer (amongst other things).</p>
<p>This bus does not have an equivalent 'response' bus; there is no way to back-pressure the BBC video subsystem, hence no way to back-pressure the display SRAM writes. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aa6d5f9d25056fff56b8dce256338f6f5"></a>bit[16]</td>
<td class="fieldname">
address</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a484b11cb41f1b1fdd30540067414c295"></a>bit[48]</td>
<td class="fieldname">
data</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ac80308b95bd3f83c8a29bae089380804"></a>bit</td>
<td class="fieldname">
enable</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structt__bbc__floppy__sector__id" id="structt__bbc__floppy__sector__id"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct t_bbc_floppy_sector_id</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>This structure is used in the request and response to a floppy drive from the FDC (floppy disc controller), for the ID read/written to a sector.</p>
<p>Each sector on a floppy has a descriptor that includes byte fields for the head, logical sector number, and the head/sector length and, and a CRC - and the sector data has its own CRC.</p>
<p>This structure fits into 32 bits, so a 32-bit wide SRAM can store this data. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a61d5faa357625138072247c4b98ac6f3"></a>bit</td>
<td class="fieldname">
bad_crc</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ae7a7379a4c325030a65409cc28ce6bdf"></a>bit</td>
<td class="fieldname">
bad_data_crc</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a65610b66ed3d9a2e4d23daf18c0fc9fd"></a>bit</td>
<td class="fieldname">
deleted_data</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="af913f3ce780ab220ffd28c2070b557cb"></a>bit</td>
<td class="fieldname">
head</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a70e71139e84a6fd678f939be1cd5b228"></a>bit[2]</td>
<td class="fieldname">
sector_length</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a574f3f9d7db8b6f26803ec2a52823c17"></a>bit[6]</td>
<td class="fieldname">
sector_number</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a88c2770d11203b5203a7cd3abee1db43"></a>bit[7]</td>
<td class="fieldname">
track</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structt__bbc__floppy__op" id="structt__bbc__floppy__op"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct t_bbc_floppy_op</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>The floppy op structure is used to convey a floppy operation from the FDC to the floppy drive; it is effectively an internal set of signals that are driven inside the FDC to the floppy controller, which converts them to analog data or other control signals to the floppy drive interface.</p>
<p>The structure has no 'valid' signal - it is valid on every clock tick. However, control signals are required to toggle on and toggle off - it is the 'rising edge' of step_out, step_in, next_id, read_data_enable, etc that cause those to occur.</p>
<p>step_out and step_in are mutually exclusive; step_out moves the head out towards the outer rim of the disc, which is where track 0 is.</p>
<p>next_id is asserted if the drive should read the next sector ID (in reality waiting for the disc to spin round until a sector id descriptors is decoded from the surface) from the disc. In response to this, some time later, a floppy response with a valid sector_id should be presented.</p>
<p>read_data_enable is asserted if the next word (32 bits) of sector data should be read from the disc surface. This should only be asserted after a 'next_id', or after a previous 'read_data_enable'. After a 'next_id' it causes the first data word of the sector for which the sector id was returned; otherwise it continues data from that sector.</p>
<p>write_data_enable and write_data are not currently used. They should be used to write the data after a 'next_id' has been asserted, at 32 bits per write.</p>
<p>write_sector_id_enable and sector_id are not currently used. They should be used to write the sector id data for a sector. This is generally done on a floppy disc controller only when formatting a track, and so in fact may never be implemented (if formatting is assumed to be hard as opposed to soft). </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a6174eeb040deaa0c9ac50d65df089018"></a>bit</td>
<td class="fieldname">
next_id</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a26feaa933929fb58a2b6920d06fe6da2"></a>bit</td>
<td class="fieldname">
read_data_enable</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="abe7a324358a35f710bc088119e0acc83"></a><a class="el" href="bbc__micro__types_8h.html#structt__bbc__floppy__sector__id">t_bbc_floppy_sector_id</a></td>
<td class="fieldname">
sector_id</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aea6dbe7d9b9f92833824a63fefae43c0"></a>bit</td>
<td class="fieldname">
step_in</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a45d5b42d2f7ba0ec88ac9b942b738213"></a>bit</td>
<td class="fieldname">
step_out</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a4ffb4ba8c55d1176ea2583dd14166d6e"></a>bit[32]</td>
<td class="fieldname">
write_data</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="adc85bd44c48840ebb48eb073b4e08e4e"></a>bit</td>
<td class="fieldname">
write_data_enable</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ae03f2703ba767bd38a1de8a54c076133"></a>bit</td>
<td class="fieldname">
write_sector_id_enable</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structt__bbc__floppy__response" id="structt__bbc__floppy__response"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct t_bbc_floppy_response</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>The floppy response structure conveys data back from the floppy drive interface to the FDC in response to the floppy operation.</p>
<p>sector_id_valid is asserted for a single clock tick in conjunction with valid sector_id data in response to a 'next_id' rising edge in the floppy operation; this may occur any number of clock ticks after the request, and in the intervening period no other requests are permitted.</p>
<p>read_data_valid is asserted for a single clock tick in conjunction with valid read_data in response to a 'read_data_enable' floppy operation; this may occur any number of clock ticks after the request, and in the intervening period no other requests are permitted.</p>
<p>index is asserted if the latest sector_id is the first physical sector of the track - i.e. if the 'index hole' on the floppy disc is at that point. On a real floppy disc the index hole need not be anywhere near an actual valid sector data field, but for the emulation the index value is valid for the whole of the period from one sector_id_valid to the next.</p>
<p>track_zero is asserted if the current track is track zero. This becomes asserted when the drive is 'stepped out' to the outermost track (i.e. the physical track number is decremented to 0).</p>
<p>disk_ready is asserted if there is a floppy in the drive.</p>
<p>write_protect is asserted if the floppy in the drive has a write protect tab on it. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a67adb6f54f96dd72e0bc0a44fa0d867a"></a>bit</td>
<td class="fieldname">
disk_ready</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a9e1c6ee43f38d82609d058ecfbbc5815"></a>bit</td>
<td class="fieldname">
index</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ae9ee40af56528394944fdd4d34835adf"></a>bit[32]</td>
<td class="fieldname">
read_data</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ac2fd3d8b53fad5af27afd29d797ecc6e"></a>bit</td>
<td class="fieldname">
read_data_valid</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="accf1f1f73750388afd6397c4d29d36d3"></a><a class="el" href="bbc__micro__types_8h.html#structt__bbc__floppy__sector__id">t_bbc_floppy_sector_id</a></td>
<td class="fieldname">
sector_id</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a1065d2aa86cea61c1a43378bd2d8d1b7"></a>bit</td>
<td class="fieldname">
sector_id_valid</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a3b22ea035fda50aab1a5892414b96613"></a>bit</td>
<td class="fieldname">
track_zero</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="afb7fb141d2903b245ff1511c449a83f0"></a>bit</td>
<td class="fieldname">
write_protect</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structt__bbc__floppy__sram__request" id="structt__bbc__floppy__sram__request"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct t_bbc_floppy_sram_request</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>To implement the floppy drive there is a CDL implementation which takes floppy operations and converts them to SRAM reads (and writes); this is a standard SRAM access request interface. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aabad505674e4ae3f8b25d63346cb68ba"></a>bit[20]</td>
<td class="fieldname">
address</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aa4a9c54153284da1a95c0c369d97a080"></a>bit</td>
<td class="fieldname">
enable</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ac5d3ad41a8464abd39f4701d84d3e5d3"></a>bit</td>
<td class="fieldname">
read_not_write</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ae48e9d55bd1b5b54799965b1ce52ef75"></a>bit[32]</td>
<td class="fieldname">
write_data</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structt__bbc__floppy__sram__response" id="structt__bbc__floppy__sram__response"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct t_bbc_floppy_sram_response</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>The CDL implementation for the floppy drive uses this as a response</p><ul>
<li>ack asserts to acknowledge a read or write request, and valid read data is returned with data_valid. </li>
</ul>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a75f4a725ea6c3b77ef6ecce2936da474"></a>bit</td>
<td class="fieldname">
ack</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a8e8cfe3ced02e6ab396c601fa40091f5"></a>bit[32]</td>
<td class="fieldname">
read_data</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ae74bf4b0aca755070e793f110e77a3ce"></a>bit</td>
<td class="fieldname">
read_data_valid</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structt__bbc__clock__control" id="structt__bbc__clock__control"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct t_bbc_clock_control</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>This structure conveys clock gating and reset information to the BBC micro CDL implementation and various peripherals and other logic. Other modules require it to determine when to clock: for example, the floppy disc controller clocks on the CPU clock, so the interface from this module to its SRAM also clocks at the same edges (i.e. clk gated by enable_cpu). </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="abe8bacbca439635030900bbd11357679"></a>bit[4]</td>
<td class="fieldname">
debug</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="afe592c3302f29efd8831857b623098e6"></a>bit</td>
<td class="fieldname">
enable_1MHz_falling</td>
<td class="fielddoc">
<p>Asserted if the rising edge of 'clk' should also be a falling '1MHz' clock edge </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a1dfaefab4afaaa59d309f9ae3bb032fb"></a>bit</td>
<td class="fieldname">
enable_1MHz_rising</td>
<td class="fielddoc">
<p>Asserted if the rising edge of 'clk' should also be a rising '1MHz' clock edge </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a1f9e576860c2f7d5a51141fd8996b3fe"></a>bit</td>
<td class="fieldname">
enable_2MHz_video</td>
<td class="fielddoc">
<p>Asserted if the rising edge of 'clk' should also be a rising video '2MHz' clock edge </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="af30b3e5f54c8e283b329bb948fb57f60"></a>bit</td>
<td class="fieldname">
enable_cpu</td>
<td class="fielddoc">
<p>Asserted if the rising edge of 'clk' should also be a rising CPU clock edge </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ab51e1224832471c10be3d40afdbb9365"></a>bit[2]</td>
<td class="fieldname">
phi</td>
<td class="fielddoc">
<p>Phase of BBC 6502 clock operation - in a real BBC micro this comes from the CPU </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a0d6e1e3fb9fa756bc68b146e9b68db7a"></a>bit</td>
<td class="fieldname">
reset_cpu</td>
<td class="fielddoc">
<p>Asserted if the CPU should be reset, controlled by a CSR register </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aed2da443611d79c0e39f75613d57d745"></a>bit</td>
<td class="fieldname">
will_enable_2MHz_video</td>
<td class="fielddoc">
<p>Asserted if 'enable_2MHz_video' will be asserted in the next 'clk' period </p>
</td></tr>
</table>

</div>
</div>
<a name="structt__bbc__clock__status" id="structt__bbc__clock__status"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct t_bbc_clock_status</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>This structure conveys information in to the clock control module from the BBC micro - the real BBC micro has complex management of the CPU and hence system bus clock based on whether a 1MHz peripheral I/O space is being accessed or not. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a0bbf01c5fdf95db8955cc79e046e10e0"></a>bit</td>
<td class="fieldname">
cpu_1MHz_access</td>
<td class="fielddoc">
<p>Asserted by the BBC micro if a 1MHz peripheral is being accessed - this the CPU clock enables to align with the 1MHz clock enables </p>
</td></tr>
</table>

</div>
</div>
<a name="structt__bbc__micro__sram__request" id="structt__bbc__micro__sram__request"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct t_bbc_micro_sram_request</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>This structure is used to enable writing and reading any SRAM within a CDL implementation; it is a bus that can be pipelined arbitrarily (both in request and response), and it may be split amongst multiple targets (hence it can be set up as a pipelined tree, with the master at the root).</p>
<p>The protocol is for the master to assert valid with the required request on the bus. The master must wait for an 'ack' from a target to reach it, when it may then remove the 'valid' (for at least one cycle). If the request has been a read, then the master must also wait for 'read_data_valid' - which may occur in the same cycle as the 'ack'.</p>
<p>Before issuing another SRAM transaction the master must wait for 'ack' to go low.</p>
<p>A target receiving a valid request should compare the 'select' lines with the SRAMs that it services, and assert 'ack' if it can handle the request. It then performs the transaction, and returns any read data with the 'read_data_valid' signal asserted. In every cycle that it does not have valid read_data the read_data and read_data_valid must be 0.</p>
<p>The target may wait for valid to be deasserted before deasserting 'ack' (if it had been the selected target). </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="af4150643a6b9c0092d5f9751140ac35e"></a>bit[24]</td>
<td class="fieldname">
address</td>
<td class="fielddoc">
<p>Constant during 'valid', indicates address in SRAM should be accessed. </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a17b78ae16a9f3eaa4f3e00725275b9ad"></a>bit</td>
<td class="fieldname">
read_enable</td>
<td class="fielddoc">
<p>Constant during 'valid', indicates if a read access is required. Exclusive with write_enable </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a45d90963991819c59fc3cac2ac858b89"></a>bit[8]</td>
<td class="fieldname">
select</td>
<td class="fielddoc">
<p>Constant during 'valid', indicates which SRAM should be accessed. Usually one of t_bbc_sram_select </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a59d12d25ebe8bed16d88bb8890eae451"></a>bit</td>
<td class="fieldname">
valid</td>
<td class="fielddoc">
<p>Asserted to indicate that an SRAM request is valid </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a3f455e65a87d708a1535edc4a7c85350"></a>bit[64]</td>
<td class="fieldname">
write_data</td>
<td class="fielddoc">
<p>Constant during 'valid', contains data to be written to SRAM (if write_enable is asserted) - ignored otherwise. </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a61bcae4cc228dde999b4c8bbb86dd797"></a>bit</td>
<td class="fieldname">
write_enable</td>
<td class="fielddoc">
<p>Constant during 'valid', indicates if a write access is required. Exclusive with read_enable </p>
</td></tr>
</table>

</div>
</div>
<a name="structt__bbc__micro__sram__response" id="structt__bbc__micro__sram__response"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct t_bbc_micro_sram_response</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>This structure conveys back towards the host the acknowledgement and any SRAM read data in response to a BBC micro SRAM read/write request. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a2f22cc9c28ae2f335713f2a7ff1d6d7e"></a>bit</td>
<td class="fieldname">
ack</td>
<td class="fielddoc">
<p>Asserted to indicate that a SRAM request has been taken - held high until valid is deasserted </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="abd69b9608f82dd959602ba8729caf18c"></a>bit[64]</td>
<td class="fieldname">
read_data</td>
<td class="fielddoc">
<p>Read data from an SRAM request, valid with read_data_valid, zero in all other cycles </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a51b250627503e95737819fe59b744dd7"></a>bit</td>
<td class="fieldname">
read_data_valid</td>
<td class="fielddoc">
<p>Asserted when the read data from an SRAM request is valid </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a5af137b3d5b55b2c9a56985083800706"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="bbc__micro__types_8h.html#a5af137b3d5b55b2c9a56985083800706">t_bbc_csr_select</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This enumeration matches the C, and it is used to select the CSR target (the 'select' field of csr_request's). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a5af137b3d5b55b2c9a56985083800706a9ee4a4b66e114dcd6900262f06568684"></a>bbc_csr_select_clocks&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a5af137b3d5b55b2c9a56985083800706a69c0335e582f51823e82af498c09ed6e"></a>bbc_csr_select_display&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a5af137b3d5b55b2c9a56985083800706ae9cfc6676412f5b0dbc4c449c19af229"></a>bbc_csr_select_floppy&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a5af137b3d5b55b2c9a56985083800706ae6f866f9c292decf83279fc4d7858361"></a>bbc_csr_select_keyboard&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a5af137b3d5b55b2c9a56985083800706a5a2500ec6c113142c4e22329b28fed83"></a>bbc_csr_select_framebuffer&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a51ee698f2790beed10c5dbed353e12d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="bbc__micro__types_8h.html#a51ee698f2790beed10c5dbed353e12d6">t_bbc_pixels_per_clock</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The BBC micro operates with a variable speed pixel clock - it can be 12MHz or 16MHz. Furthermore, for some graphics 'modes' the number of real pixels per clock tick drops as pixels are replicated, to enable pixel information to be used for color selection. Hence 8 pixel per clock at 2MHz is 2 colors for 16Mpps, whereas 2 pixels per clock at 2MHz indicates 16Mpps where each pixel is replicated 4 times over, and can be of 2^4=16 different colors. Mode 2 uses bbc_ppc_2; modes 1 and 5 use bbc_ppc_4; modes 0, 3, 4 and 6 use bbc_ppc_8. Note that modes 0-3 run with 640 base pixels at 16MHz, hence 40us of pixel data per row.</p>
<p>For teletext mode the pixel rate is officially 12Mpps, as the teletext characters are 12 pixels wide and there are 40 characters per screen (hence roughly 480 pixels wide, and at 12Mpps that is 40us). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a51ee698f2790beed10c5dbed353e12d6a1cf479e55c0f6a6a54a75568b0fac2ee"></a>bbc_ppc_1&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a51ee698f2790beed10c5dbed353e12d6a368f7255dceaf9746d6516fc936fe5cc"></a>bbc_ppc_2&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a51ee698f2790beed10c5dbed353e12d6a05d9a40c81ac220076fe3a94b2c8785a"></a>bbc_ppc_4&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a51ee698f2790beed10c5dbed353e12d6a55dd803f4ea17389d2061cf2a4529f65"></a>bbc_ppc_6&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a51ee698f2790beed10c5dbed353e12d6a0b3ca4328f764f7d8498e2a8e4d2f2ee"></a>bbc_ppc_8&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ac4b75e2f51d5bd3163e0b149f3fdd95b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="bbc__micro__types_8h.html#ac4b75e2f51d5bd3163e0b149f3fdd95b">t_bbc_sram_select</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This enumeration matches the C, and it is used to select the SRAM target for host SRAM transactions </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ac4b75e2f51d5bd3163e0b149f3fdd95baf07234e37f7d06f240f83d4a5b85bb11"></a>bbc_sram_select_micro&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac4b75e2f51d5bd3163e0b149f3fdd95bac37abdb49644780f910144ba6a8de3bb"></a>bbc_sram_select_display&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac4b75e2f51d5bd3163e0b149f3fdd95baf318febf0ea7251d51c5b2d7c8e96bdd"></a>bbc_sram_select_floppy&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac4b75e2f51d5bd3163e0b149f3fdd95ba072ca0f41e8ce2dcf74f21f2fbd0bf55"></a>bbc_sram_select_cpu&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac4b75e2f51d5bd3163e0b149f3fdd95ba9612dbdf7efa46010c8dccfaefc10c97"></a>bbc_sram_select_cpu_ram_0&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac4b75e2f51d5bd3163e0b149f3fdd95ba7540f47faa13853156d7d799e0ca4788"></a>bbc_sram_select_cpu_ram_1&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac4b75e2f51d5bd3163e0b149f3fdd95bafc4212f67cbaeb213173caba0a4d2611"></a>bbc_sram_select_cpu_os&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac4b75e2f51d5bd3163e0b149f3fdd95ba2ee979e2140def0be868f4eb44eb932f"></a>bbc_sram_select_cpu_teletext&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac4b75e2f51d5bd3163e0b149f3fdd95bac975572c2d4aec3c2a2374f8a759badf"></a>bbc_sram_select_cpu_rom_0&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac4b75e2f51d5bd3163e0b149f3fdd95ba3e4d9b1f0f56cc53d11ec951df844620"></a>bbc_sram_select_cpu_rom_1&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac4b75e2f51d5bd3163e0b149f3fdd95ba4d76984004b14d111cfc3753e0068fce"></a>bbc_sram_select_cpu_rom_2&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac4b75e2f51d5bd3163e0b149f3fdd95ba25d3e957a48c44146db6495500f16de3"></a>bbc_sram_select_cpu_rom_3&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Sep 30 2018 17:21:43 for CDL Modules by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
