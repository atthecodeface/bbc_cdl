<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>CDL Modules: riscv_i32_muldiv</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CDL Modules
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a>  </div>
  <div class="headertitle">
<div class="title">riscv_i32_muldiv</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:riscv__i32__alu_8cdl"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="riscv__i32__alu_8cdl.html">riscv_i32_alu.cdl</a></td></tr>
<tr class="memdesc:riscv__i32__alu_8cdl"><td class="mdescLeft">&#160;</td><td class="mdescRight">ALU for i32 RISC-V implementation. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Modules</h2>
<a class="anchor" id="ga2bf5db6f66343fc99d28c3116fb008f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">module riscv_i32_muldiv::riscv_i32_muldiv </td>
          <td>(</td>
          <td class="paramtype">clock&#160;</td>
          <td class="paramname"><em>clk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input bit&#160;</td>
          <td class="paramname"><em>reset_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input <a class="el" href="riscv__internal__types_8h.html#structt__riscv__i32__coproc__controls">t_riscv_i32_coproc_controls</a>&#160;</td>
          <td class="paramname"><em>coproc_controls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">output <a class="el" href="riscv__internal__types_8h.html#structt__riscv__i32__coproc__response">t_riscv_i32_coproc_response</a>&#160;</td>
          <td class="paramname"><em>coproc_response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">input <a class="el" href="riscv_8h.html#structt__riscv__config">t_riscv_config</a>&#160;</td>
          <td class="paramname"><em>riscv_config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">riscv_config</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Multiplication:</p>
<p>Consider multiplication of two 3-bit numbers a and b (hence octal)</p>
<p>A straight (unsigned) view of a value X as Xs.Xb is Xb+4*Xs (Xs is sign bit, Xb remaining bits) A signed view of a value X as Xs.Xb is Xb-4*Xs Hence one can consider Xsigned = Xunsigned - 8*Xs</p>
<p>Consider Runsigned = Xunsigned * Yunsigned Then Xsigned * Ysigned = (Xunsigned - 8*Xs) * (Yunsigned - 8*Ys) = (Xunsigned*Yunsigned) + 64*Xs*Ys -8*(Xs*Yunsigned + Ys*Xunsigned) (mod 64) = Runsigned -8*(Xs*Yunsigned + Ys*Xunsigned)</p>
<p>Xunsigned * Yunsigned has the following multiplication table: </p><pre class="fragment">0    1    2    3    4    5    6    7    
</pre><p> 0 0 0 0 0 0 0 0 0 1 0 1 2 3 4 5 6 7 2 0 2 4 6 10 12 14 16 3 0 3 6 11 14 17 22 25 4 0 4 10 14 20 24 30 34 5 0 5 12 17 24 31 36 43 6 0 6 14 22 30 36 44 52 7 0 7 16 25 34 43 52 61</p>
<p>If both are signed then we have the following correction to add -8*(Xs*Yunsigned + Ys*Xunsigned) (in decimal...) </p><pre class="fragment">0    1    2    3    4    5    6    7    
</pre><p> 0 0 0 0 0 0 0 0 0 1 0 0 0 0 -8 -8 -8 -8 2 0 0 0 0 -16 -16 -16 -16 3 0 0 0 0 -24 -24 -24 -24 4 0 -8 -16 -24 -64 -72 -80 -88 5 0 -8 -16 -24 -72 -80 -88 -96 6 0 -8 -16 -24 -80 -88 -96 -104 7 0 -8 -16 -24 -88 -96 -104 -112</p>
<p>And in octal (addition) </p><pre class="fragment">0    1    2    3    4    5    6    7    
</pre><p> 0 0 0 0 0 0 0 0 0 1 0 0 0 0 70 70 70 70 2 0 0 0 0 60 60 60 60 3 0 0 0 0 50 50 50 50 4 0 70 60 50 0 70 60 50 5 0 70 60 50 70 60 50 40 6 0 70 60 50 60 50 40 30 7 0 70 60 50 50 40 30 20</p>
<p>If they are both signed (7==-1, 6==-2, 5=&ndash;3, 4==-4) we have the following multiplication table: </p><pre class="fragment">0    1    2    3    4    5    6    7
</pre><p> 0 0 0 0 0 0 0 0 0 1 0 1 2 3 74 75 76 77 2 0 2 4 6 70 72 74 76 3 0 3 6 11 64 67 72 75 4 0 74 70 64 20 14 10 4 5 0 75 72 67 14 11 6 3 6 0 76 74 72 10 6 4 2 7 0 77 76 75 4 3 2 1</p>
<p>If the column (X) in unsigned and the row is signed then we have the following correction to add -8*Ys*Xunsigned (in decimal...) </p><pre class="fragment">0    1    2    3    4    5    6    7    
</pre><p> 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 4 0 -8 -16 -24 -32 -40 -48 -56 5 0 -8 -16 -24 -32 -40 -48 -56 6 0 -8 -16 -24 -32 -40 -48 -56 7 0 -8 -16 -24 -32 -40 -48 -56</p>
<p>And in octal (addition) </p><pre class="fragment">0    1    2    3    4    5    6    7    
</pre><p> 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 4 0 70 60 50 40 30 20 10 5 0 70 60 50 40 30 20 10 6 0 70 60 50 40 30 20 10 7 0 70 60 50 40 30 20 10</p>
<p>Hence the multiplication table: </p><pre class="fragment">0    1    2    3    4    5    6    7
</pre><p> 0 0 0 0 0 0 0 0 0 1 0 1 2 3 4 5 6 7 2 0 2 4 6 10 12 14 16 3 0 3 6 11 14 17 22 25 4 0 74 70 64 60 54 50 44 5 0 75 72 67 64 61 56 53 6 0 76 74 72 70 66 64 62 7 0 77 76 75 74 73 72 71</p>
<p>Hence the multiplication of two 32-bit numbers X and Y, using a 64-bit accumulator A, can be performed by setting A initially to:</p>
<p>0 for unsigned*unsigned -2^32*(X[31]?Y) for X signed Y unsigned -2^32*(Y[31]?X) for Y signed X unsigned -2^32*(Y[31]?X[31;0] + X[31]?Y[31;0]) for both signed.</p>
<p>The operation of the multiply then requires a 64-bit accumulator</p>
<p>+1 +4 provides 0, 1, 4, 5 (single 35-bit adder) (stage1_0 = 0; stage1_1 = (3b0,in); stage1_4 = (1b0,in,2b0); stage1_5 = stage1_1 + stage1_4;)</p>
<p>+1 +4 with optional double provides 0, 2, 8, 10, 1, 3, 9, 11, 4, 6, 12, 14, 5, 7, 13, 15 (one more 36-bit adders) (0 = 0+0; 2=0+stage1_1_dbl; 3=stage1_1+stage1_1_dbl; stage2_add_in_0 = mux(stage1_0, stage1_1, stage1_4, stage1_5) stage2_add_in_1 = mux(stage1_0, stage1_1, stage1_4, stage1_5)&lt;&lt;1</p>
<p>Division</p>
<p>Unsigned division/remainder (column / row) </p><pre class="fragment">0    1    2    3    4    5    6    7
</pre><p> 0 7/0 7/0 7/0 7/0 7/0 7/0 7/0 7/0 1 0/0 1/0 2/0 3/0 4/0 5/0 6/0 7/0 2 0/0 0/1 1/0 1/1 2/0 2/1 3/0 3/1 3 0/0 0/1 0/2 1/0 1/1 1/2 2/0 2/1 4 0/0 0/1 0/2 0/3 1/0 1/1 1/2 1/3 5 0/0 0/1 0/2 0/3 0/4 1/0 1/1 1/2 6 0/0 0/1 0/2 0/3 0/4 0/5 1/0 1/1 7 0/0 0/1 0/2 0/3 0/4 0/5 0/6 1/0</p>
<p>Signed division/remainder (column / row) (x86 except div by 0) Note: x86, C99 - sign of remainder = sign of dividend </p><pre class="fragment">0    1    2    3    4    5    6    7
</pre><p> 0 7/0 7/0 7/0 7/0 7/0 7/0 7/0 7/0 1 0/0 1/0 2/0 3/0 4/0 5/0 6/0 7/0 2 0/0 0/1 1/0 1/1 6/0 7/7 7/0 0/7 3 0/0 0/1 0/2 1/0 7/7 7/0 0/6 0/7 4 0/0 0/1 0/2 0/3 1/0 0/5 0/6 0/7 5 0/0 0/1 0/2 7/0 1/7 1/0 0/6 0/7 6 0/0 0/1 7/0 7/1 2/0 1/7 1/0 0/7 7 0/0 7/0 6/0 5/0 4/0 3/0 2/0 1/0</p>
<p>For positive/positive one can use unsigned division directly For negative/negative one can do -d/-r, and negate the remainder For negative/positive one can do -d/r, then negate the result and the remainder For positive/negative one can do d/-r, then negate the result</p>
<p>So the first cycle of a divide prepares 'positive' d and r and records the signs (as required)</p>
<p>The multiply requires three adders One 34 bit; one 36 bit, one 64 bit. Divide requires compare; it could do 3 compares per cycle, or just one to start with</p>
<p>We have a multiplier register that gets shifted; this can be the divisor that gets shifted</p>
<p>Multiply then occurs with the following states:</p>
<p>Init : adder high 0 is zero or abs(a) if signed and a negative; adder high 1 is zero or abs(b) if signed and b negative; a_reg &lt;= rs1, b_reg &lt;= rs2 Step (until completed) : a_reg = a_reg&gt;&gt;4; mult=a_reg&amp;15; shf=stage; adder is shifter + acc, with carry chain. complete if a_reg&amp;15 will be 0 Result valid: accumulator has result (present top or bottom half)</p>
<p>Divide occurs with the following states:</p>
<p>Init Shift Step (until completed) Result valid (provides result signing stuff)</p>
<p>Hence the design is for a data pipeline with (for multiply):</p>
<p>a_reg - contains multiplier b_reg - contains multiplicand accumulator - contains 64-bit result of multiply</p><ul>
<li>initialize with 0 for unsigned*unsigned; -2^32*(X[31]?Y) for X signed Y unsigned; -2^32*(Y[31]?X) for Y signed X unsigned; -2^32*(Y[31]?X[31;0] + X[31]?Y[31;0]) for both signed mult_data = b_reg * bottom 4 bits of a_reg mult_shf = b_reg * bottom 4 bits of a_reg shifted to be in correct position for accumulation (i.e. shift left by 4*stage) 64-bit adder of accumulator plus mult_shf</li>
</ul>
<p>Result is accumulator - pick top or bottom 32 bits as required</p>
<p>For divide it becomes:</p>
<p>a_reg - contains abs(a) (if signed) else a (dividend) b_reg - contains -abs(b) (if signed) else -b (divisor) accumulator - bottom 32 bits contains remainder (initialized to a_reg)</p><ul>
<li>top 32 bits contain quotient (initialized to zero) mult_data = b_reg &lt;&lt; bottom 2 bits of stage mult_shf = b_reg shifted to be in correct position for subtraction from remainder 32-bit adder of low accumulator plus mult_shf; if &gt;=0 then must update accumulator low and set bit in accumulator high 32-bit 'set bit N of' of high accumulator to build quotient if</li>
</ul>
<p>Quotient result is accumulator high, or negated accumulator high if signed and signs of two inputs differ Remainder result is accumulator low, or negated accumulator low if signed and dividend input was negative </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Sep 30 2018 17:21:43 for CDL Modules by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
