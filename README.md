# CDL Hardware Repository

This repository contains hardware modules in CDL that scale from
general utilities, CSR handling, and input output, down to simple CPUs
and peripherals.

[https://atthecodeface.github.io/cdl_hardware/cdl_external_html/index.html]

There are regression tests for most modules, and they are fully
documented (well, at present about 65% fully documented, but quickly
being completed).

The modules are pulled together to form some small systems, including
a complete BBC microcomputer implementation.

## Purpose

The original purpose of this respository was to provide some more open
source CDL hardware designs on top of the original *GIP*
implementation (which was CDL 0.6 compatible) and on top of the CDL
source regression code. This then helps enable the design of a
hardware intermediate represenation (IR) that can be targeted
efficiently at FPGAs, simulation/emulation and real ASICs.

## Plans

Immediate plans are:

* to complete implementations of RISC-V

* to finish the conversion of the *GIP* to the latest CDL - this is a
  CPU designed in 2002 that executes a 16-bit instruction set, and has
  a parallel decode for ARM 32-bit instructions generated by GCC,
  hence it can run embedded ARM linux.

## Summary of CDL source directories

Modules are broadly grouped by function into directories, and they are
all in the cdl directory

### cdl/utils - solid regression 

Utils is for generic modules that may be used in many different areas
of design - general purpose utilities, in essence.

* dprintf: A debug printf module that takes requests of up to 32
  bytes, and treats it much as a printf in C, allowing for hexadecimal
  and decimal formatted numbers; it works well with teletext
  framebuffer.

* dprintf_*_mux: Multiplexers to permit multiple sources of dprintf
  strings to a dprintf module, so a single formatter can be used with
  multiple requesters.

* hysteresis_switch: An input-pin filter with hysteresis to allow for
  example to debounce switches.

### cdl/csr - solid regression 

CSRs contains modules that implement a pipelined CSR (control/status
register) interface; being pipelined this bus can be used across an
ASIC or FPGA to meet timing simply. The bus uses a master-to-target
tree, with a wired-or response path; registers may be placed in either
direction along the way.

* csr_master_apb: an APB target that drives the CSR interface; this is
  generally the top of the CSR pipelined bus.

* csr_target_apb: a CSR target that drives an APB bus to a single APB
  peripheral; this is a leaf of the CSR pipelined bus.

* csr_target_csr: a CSR target that drives a same-cycle CSR read/write
  access bus, the simplest way to access registers in a target at the
  leaf of the CSR pipelined bus.

### cdl/input_devices - solid regression

This directory currently contains just a PS2 keyboard host controller
and key mapper, which permit a PS2 keyboard to be attached (for
example) to an FPGA.

* ps2_host: A module that is currently receive-only, for a PS2
  keyboard or mouse.

* ps2_host_keyboard: This module maps the PS2 received data from a
  ps2_host module into key up/down events for 8-bit key numbers, and
  for extended keys (basically a standard PS2 keyboard).

### cdl/led - solid regression

This directory contains a simple 7-segment display decoder for
hexadecimal (actually not regression tested), and an Adafruit Neopixel
LED chain driver that can drive any length of Neopixels with 24-bit
RGB values.

* led_seven_segment: very simple module to provide the LED values for
  hexadecimal values on a 7-segment display

* led_ws2812_chain: driver for Adafruit Neopixel LED chains; it
  requests a single 24-bit RGB at a time, and will load the chain up
  by modulating the LED chain 'data_in' pin as required.

### cdl/video - some regression (teletext)

This directory contains simple framebuffer modules and a teletext
decoder. The teletext decoder permits very simple debug data to be
presented to a VGA or LCD display (or even SXGA...) using the
companion 'dprintf' module.

This directory also contains implementations of some video chips, used
in various older microcomputer systems.

* framebuffer: a framebuffer that at present is fixed to a maximum 64k
  pixels, using a dual-port 16kx48 SRAM, including the complete timing
  required for horizontal and vertical synchronization. It takes an
  SRAM write clock and a video read clock. The very current
  implementation drops every other horizontal pixel to downsize the
  image by a factor of 2.

* framebuffer_teletext: a teletext framebuffer that at present is
  fixed to a maximum 16k characters, using a dual-port 16kx8 SRAM, and
  also including the teletext character ROM, including the complete
  timing required for horizontal and vertical synchronization. It
  takes an SRAM write clock and a video read clock. It includes the
  teletext decoder running at full performance (i.e. smoothing turned
  on, 12x20 character display).

* teletext: a teletext decoder capable of decoding arbitrary-sized
  teletext presentation level 1.0 data, using an external character
  ROM. The module maintains the character scanline and other timing
  details, and it provides for double height characters and smoothing
  of characters.

* saa5050: an implementation of the SAA5050 Mullard teletext decoder,
  used in the BBC microcomputer; this modules uses the teletext
  decoder module, and is now basically just a simple wrapper for that
  module.

* crtc6845: an implementation of the Motorola 6845 cathode ray tube
  controller - this is a configurable timing and address generator
  that is used to create synchronization signals and addresses for
  video displays. It is particularly used in the BBC microcomputer.

### cdl/apb - solid regression

This directory contains a number of APB targets and masters, and an
APB arbiter/multiplexer.

* apb_processor: an APB master that runs a very simple script language
  from a ROM permitting APB reads and writes, where the data read back
  can be mainpulated simply, and simple flow control. This permits
  configuration of APB targets from a simple ROM without a full-blown
  CPU.

* apb_target_timer: a simple APB target timer peripheral with a 31-bit
  timer and three equality comparators

* apb_target_rv_timer: a more sophisticated APB target timer
  peripheral that is compatible with RISC-V platform requirements,
  with a 64-bit timer and a single 64-bit greater-than
  comparator. This supports fractional addition under timer control to
  provide for an accurate 64-bit nanosecond timer in a system,
  independent of clock frequency

* apb_target_sram_interface.cdl: a simple APB target that generates
  pipeline SRAM read/write requests, to allow for reading/writing of
  SRAMs relatively simply from a distance.

* apb_target_gpio.cdl: a simple APB target for GPIO inputs/outputs.

* apb_target_dprintf.cdl: a simple APB target that drives the
  utils/dprintf module to permit debug 'printf' to SRAMs
  (e.g. framebuffers) or (when implemented later...) UARTs.

* apb_target_led_ws2812: an APB target that drives a chain of up to 16
  Neopixel LEDs with full RGB

* apb_target_ps2_host: an APB target that provides access to a PS/2
  host interface, for example to interface with a PS/2 keyboard.

* apb_target_de1_cl_inputs.cdl: an APB target that allows access to
  the state of the Cambridge University CL DE1-SOC daughterboard inputs.

* apb_master_mux: a two-input APB master arbiter/multiplexer,
  permitting two APB masters to access a set of APB targets

* apb_master_axi: an AXI target that is an APB master for reads and writes

### CPU, apb, boards, bbc, serial, storage

to be written up here yet
